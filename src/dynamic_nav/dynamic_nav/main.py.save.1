import math

import rclpy
from rclpy.node import Node

from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan


class DynamicNavNode(Node):
    """
    Τοπικός πλοηγός για TurtleBot3 με παραμέτρους:
    - forward_speed [m/s]
    - rotate_speed [rad/s]
    - obstacle_threshold [m]
    - clear_threshold [m]
    - control_period [s]
    """

    def __init__(self):
        super().__init__("dynamic_nav_node")

        # --- Δήλωση παραμέτρων με default τιμές ---
        self.declare_parameter("forward_speed", 0.2)
        self.declare_parameter("rotate_speed", 0.5)
        self.declare_parameter("obstacle_threshold", 0.5)
        self.declare_parameter("clear_threshold", 0.8)
        self.declare_parameter("control_period", 0.1)

        # Ανάγνωση τιμών παραμέτρων
        self.forward_speed = self.get_parameter("forward_speed").value
        self.rotate_speed = self.get_parameter("rotate_speed").value
        self.obstacle_threshold = self.get_parameter("obstacle_threshold").value
        self.clear_threshold = self.get_parameter("clear_threshold").value
        control_period = self.get_parameter("control_period").value

        self.get_logger().info(
            "Dynamic navigation node started with parameters:\n"
            f"  forward_speed      = {self.forward_speed:.2f} m/s\n"
            f"  rotate_speed       = {self.rotate_speed:.2f} rad/s\n"
            f"  obstacle_threshold = {self.obstacle_threshold:.2f} m\n"
            f"  clear_threshold    = {self.clear_threshold:.2f} m\n"
            f"  control_period     = {control_period:.2f} s"
        )

        # Publisher για ταχύτητες
        self.cmd_pub = self.create_publisher(Twist, "/cmd_vel", 10)

        # Subscriber για LaserScan
        self.scan_sub = self.create_subscription(
            LaserScan, "/scan", self.scan_callback, 10
        )

        # Ελάχιστη απόσταση μπροστά (ενημερώνεται από το scan)
        self.min_front_dist = None

        # Κατάσταση: "FORWARD" ή "ROTATING"
        self.state = "FORWARD"

        # Timer loop ελέγχου
        self.control_timer = self.create_timer(control_period, self.control_loop)

    def scan_callback(self, msg: LaserScan):
        """Επεξεργασία του LaserScan για να βρούμε την ελάχιστη απόσταση μπροστά."""
        ranges = list(msg.ranges)
        n = len(ranges)
        if n == 0:
            return

        # Παράθυρο μπροστά από το ρομπότ (περίπου ~60°)
        window_size = max(10, n // 6)
        center = n // 2
        start = max(0, center - window_size // 2)
        end = min(n, center + window_size // 2)

        front_ranges = []
        for r in ranges[start:end]:
            if math.isfinite(r) and r > 0.0:
                front_ranges.append(r)

        if front_ranges:
            self.min_front_dist = min(front_ranges)
        else:
            self.min_front_dist = None

    def control_loop(self):
        """Finite-state λογική πλοήγησης με obstacle avoidance."""
        twist = Twist()

        # Αν δεν έχουμε ακόμα έγκυρο scan, δεν κινούμαστε
        if self.min_front_dist is None:
            self.cmd_pub.publish(twist)
            return

        if self.state == "FORWARD":
            if self.min_front_dist < self.obstacle_threshold:
                # Εμπόδιο πολύ κοντά -> κατάσταση περιστροφής
                self.get_logger().info(
                    f"Obstacle detected at {self.min_front_dist:.2f} m, re-routing..."
                )
                self.state = "ROTATING"
                twist.linear.x = 0.0
                twist.angular.z = self.rotate_speed
            else:
                # Καθαρός δρόμος -> κίνηση ευθεία
                twist.linear.x = self.forward_speed
                twist.angular.z = 0.0

        elif self.state == "ROTATING":
            if self.min_front_dist > self.clear_threshold:
                # Ο δρόμος μπροστά καθάρισε -> συνεχίζουμε ευθεία
                self.get_logger().info(
                    f"Path is clear again ({self.min_front_dist:.2f} m), "
                    "resuming forward motion."
                )
                self.state = "FORWARD"
                twist.linear.x = self.forward_speed
                twist.angular.z = 0.0
            else:
                # Συνεχίζουμε να περιστρέφουμε μέχρι να βρεθεί κενός χώρος
                twist.linear.x = 0.0
                twist.angular.z = self.rotate_speed

        self.cmd_pub.publish(twist)


def main(args=None):
    rclpy.init(args=args)
    node = DynamicNavNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.get_logger().info("Shutting down dynamic navigation node.")
        node.destroy_node()
        rclpy.shutdown()

